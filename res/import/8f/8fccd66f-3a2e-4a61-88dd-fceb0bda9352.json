{"__type__":"cc.TextAsset","_name":"descriptor","text":"// Protocol Buffers - Google's data interchange format\r\n// Copyright 2008 Google Inc.  All rights reserved.\r\n// http://code.google.com/p/protobuf/\r\n//\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are\r\n// met:\r\n//\r\n//     * Redistributions of source code must retain the above copyright\r\n// notice, this list of conditions and the following disclaimer.\r\n//     * Redistributions in binary form must reproduce the above\r\n// copyright notice, this list of conditions and the following disclaimer\r\n// in the documentation and/or other materials provided with the\r\n// distribution.\r\n//     * Neither the name of Google Inc. nor the names of its\r\n// contributors may be used to endorse or promote products derived from\r\n// this software without specific prior written permission.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\n// Author: kenton@google.com (Kenton Varda)\r\n//  Based on original Protocol Buffers design by\r\n//  Sanjay Ghemawat, Jeff Dean, and others.\r\n//\r\n// The messages in this file describe the definitions found in .proto files.\r\n// A valid .proto file can be translated directly to a FileDescriptorProto\r\n// without any other information (e.g. without reading its imports).\r\n\r\n\r\n\r\npackage google.protobuf;\r\noption java_package = \"com.google.protobuf\";\r\noption java_outer_classname = \"DescriptorProtos\";\r\n\r\n// descriptor.proto must be optimized for speed because reflection-based\r\n// algorithms don't work during bootstrapping.\r\noption optimize_for = SPEED;\r\n\r\n// The protocol compiler can output a FileDescriptorSet containing the .proto\r\n// files it parses.\r\nmessage FileDescriptorSet {\r\n  repeated FileDescriptorProto file = 1;\r\n}\r\n\r\n// Describes a complete .proto file.\r\nmessage FileDescriptorProto {\r\n  optional string name = 1;       // file name, relative to root of source tree\r\n  optional string package = 2;    // e.g. \"foo\", \"foo.bar\", etc.\r\n\r\n  // Names of files imported by this file.\r\n  repeated string dependency = 3;\r\n\r\n  // All top-level definitions in this file.\r\n  repeated DescriptorProto message_type = 4;\r\n  repeated EnumDescriptorProto enum_type = 5;\r\n  repeated ServiceDescriptorProto service = 6;\r\n  repeated FieldDescriptorProto extension = 7;\r\n\r\n  optional FileOptions options = 8;\r\n\r\n  // This field contains optional information about the original source code.\r\n  // You may safely remove this entire field whithout harming runtime\r\n  // functionality of the descriptors -- the information is needed only by\r\n  // development tools.\r\n  optional SourceCodeInfo source_code_info = 9;\r\n}\r\n\r\n// Describes a message type.\r\nmessage DescriptorProto {\r\n  optional string name = 1;\r\n\r\n  repeated FieldDescriptorProto field = 2;\r\n  repeated FieldDescriptorProto extension = 6;\r\n\r\n  repeated DescriptorProto nested_type = 3;\r\n  repeated EnumDescriptorProto enum_type = 4;\r\n\r\n  message ExtensionRange {\r\n    optional int32 start = 1;\r\n    optional int32 end = 2;\r\n  }\r\n  repeated ExtensionRange extension_range = 5;\r\n\r\n  optional MessageOptions options = 7;\r\n}\r\n\r\n// Describes a field within a message.\r\nmessage FieldDescriptorProto {\r\n  enum Type {\r\n    // 0 is reserved for errors.\r\n    // Order is weird for historical reasons.\r\n    TYPE_DOUBLE         = 1;\r\n    TYPE_FLOAT          = 2;\r\n    TYPE_INT64          = 3;   // Not ZigZag encoded.  Negative numbers\r\n                               // take 10 bytes.  Use TYPE_SINT64 if negative\r\n                               // values are likely.\r\n    TYPE_UINT64         = 4;\r\n    TYPE_INT32          = 5;   // Not ZigZag encoded.  Negative numbers\r\n                               // take 10 bytes.  Use TYPE_SINT32 if negative\r\n                               // values are likely.\r\n    TYPE_FIXED64        = 6;\r\n    TYPE_FIXED32        = 7;\r\n    TYPE_BOOL           = 8;\r\n    TYPE_STRING         = 9;\r\n    TYPE_GROUP          = 10;  // Tag-delimited aggregate.\r\n    TYPE_MESSAGE        = 11;  // Length-delimited aggregate.\r\n\r\n    // New in version 2.\r\n    TYPE_BYTES          = 12;\r\n    TYPE_UINT32         = 13;\r\n    TYPE_ENUM           = 14;\r\n    TYPE_SFIXED32       = 15;\r\n    TYPE_SFIXED64       = 16;\r\n    TYPE_SINT32         = 17;  // Uses ZigZag encoding.\r\n    TYPE_SINT64         = 18;  // Uses ZigZag encoding.\r\n  };\r\n\r\n  enum Label {\r\n    // 0 is reserved for errors\r\n    LABEL_OPTIONAL      = 1;\r\n    LABEL_REQUIRED      = 2;\r\n    LABEL_REPEATED      = 3;\r\n    // TODO(sanjay): Should we add LABEL_MAP?\r\n  };\r\n\r\n  optional string name = 1;\r\n  optional int32 number = 3;\r\n  optional Label label = 4;\r\n\r\n  // If type_name is set, this need not be set.  If both this and type_name\r\n  // are set, this must be either TYPE_ENUM or TYPE_MESSAGE.\r\n  optional Type type = 5;\r\n\r\n  // For message and enum types, this is the name of the type.  If the name\r\n  // starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping\r\n  // rules are used to find the type (i.e. first the nested types within this\r\n  // message are searched, then within the parent, on up to the root\r\n  // namespace).\r\n  optional string type_name = 6;\r\n\r\n  // For extensions, this is the name of the type being extended.  It is\r\n  // resolved in the same manner as type_name.\r\n  optional string extendee = 2;\r\n\r\n  // For numeric types, contains the original text representation of the value.\r\n  // For booleans, \"true\" or \"false\".\r\n  // For strings, contains the default text contents (not escaped in any way).\r\n  // For bytes, contains the C escaped value.  All bytes >= 128 are escaped.\r\n  // TODO(kenton):  Base-64 encode?\r\n  optional string default_value = 7;\r\n\r\n  optional FieldOptions options = 8;\r\n}\r\n\r\n// Describes an enum type.\r\nmessage EnumDescriptorProto {\r\n  optional string name = 1;\r\n\r\n  repeated EnumValueDescriptorProto value = 2;\r\n\r\n  optional EnumOptions options = 3;\r\n}\r\n\r\n// Describes a value within an enum.\r\nmessage EnumValueDescriptorProto {\r\n  optional string name = 1;\r\n  optional int32 number = 2;\r\n\r\n  optional EnumValueOptions options = 3;\r\n}\r\n\r\n// Describes a service.\r\nmessage ServiceDescriptorProto {\r\n  optional string name = 1;\r\n  repeated MethodDescriptorProto method = 2;\r\n\r\n  optional ServiceOptions options = 3;\r\n}\r\n\r\n// Describes a method of a service.\r\nmessage MethodDescriptorProto {\r\n  optional string name = 1;\r\n\r\n  // Input and output type names.  These are resolved in the same way as\r\n  // FieldDescriptorProto.type_name, but must refer to a message type.\r\n  optional string input_type = 2;\r\n  optional string output_type = 3;\r\n\r\n  optional MethodOptions options = 4;\r\n}\r\n\r\n// ===================================================================\r\n// Options\r\n\r\n// Each of the definitions above may have \"options\" attached.  These are\r\n// just annotations which may cause code to be generated slightly differently\r\n// or may contain hints for code that manipulates protocol messages.\r\n//\r\n// Clients may define custom options as extensions of the *Options messages.\r\n// These extensions may not yet be known at parsing time, so the parser cannot\r\n// store the values in them.  Instead it stores them in a field in the *Options\r\n// message called uninterpreted_option. This field must have the same name\r\n// across all *Options messages. We then use this field to populate the\r\n// extensions when we build a descriptor, at which point all protos have been\r\n// parsed and so all extensions are known.\r\n//\r\n// Extension numbers for custom options may be chosen as follows:\r\n// * For options which will only be used within a single application or\r\n//   organization, or for experimental options, use field numbers 50000\r\n//   through 99999.  It is up to you to ensure that you do not use the\r\n//   same number for multiple options.\r\n// * For options which will be published and used publicly by multiple\r\n//   independent entities, e-mail kenton@google.com to reserve extension\r\n//   numbers.  Simply tell me how many you need and I'll send you back a\r\n//   set of numbers to use -- there's no need to explain how you intend to\r\n//   use them.  If this turns out to be popular, a web service will be set up\r\n//   to automatically assign option numbers.\r\n\r\n\r\nmessage FileOptions {\r\n\r\n  // Sets the Java package where classes generated from this .proto will be\r\n  // placed.  By default, the proto package is used, but this is often\r\n  // inappropriate because proto packages do not normally start with backwards\r\n  // domain names.\r\n  optional string java_package = 1;\r\n\r\n\r\n  // If set, all the classes from the .proto file are wrapped in a single\r\n  // outer class with the given name.  This applies to both Proto1\r\n  // (equivalent to the old \"--one_java_file\" option) and Proto2 (where\r\n  // a .proto always translates to a single class, but you may want to\r\n  // explicitly choose the class name).\r\n  optional string java_outer_classname = 8;\r\n\r\n  // If set true, then the Java code generator will generate a separate .java\r\n  // file for each top-level message, enum, and service defined in the .proto\r\n  // file.  Thus, these types will *not* be nested inside the outer class\r\n  // named by java_outer_classname.  However, the outer class will still be\r\n  // generated to contain the file's getDescriptor() method as well as any\r\n  // top-level extensions defined in the file.\r\n  optional bool java_multiple_files = 10 [default=false];\r\n\r\n  // If set true, then the Java code generator will generate equals() and\r\n  // hashCode() methods for all messages defined in the .proto file. This is\r\n  // purely a speed optimization, as the AbstractMessage base class includes\r\n  // reflection-based implementations of these methods.\r\n  optional bool java_generate_equals_and_hash = 20 [default=false];\r\n\r\n  // Generated classes can be optimized for speed or code size.\r\n  enum OptimizeMode {\r\n    SPEED = 1;        // Generate complete code for parsing, serialization,\r\n                      // etc.\r\n    CODE_SIZE = 2;    // Use ReflectionOps to implement these methods.\r\n    LITE_RUNTIME = 3; // Generate code using MessageLite and the lite runtime.\r\n  }\r\n  optional OptimizeMode optimize_for = 9 [default=SPEED];\r\n\r\n\r\n\r\n\r\n  // Should generic services be generated in each language?  \"Generic\" services\r\n  // are not specific to any particular RPC system.  They are generated by the\r\n  // main code generators in each language (without additional plugins).\r\n  // Generic services were the only kind of service generation supported by\r\n  // early versions of proto2.\r\n  //\r\n  // Generic services are now considered deprecated in favor of using plugins\r\n  // that generate code specific to your particular RPC system.  Therefore,\r\n  // these default to false.  Old code which depends on generic services should\r\n  // explicitly set them to true.\r\n  optional bool cc_generic_services = 16 [default=false];\r\n  optional bool java_generic_services = 17 [default=false];\r\n  optional bool py_generic_services = 18 [default=false];\r\n\r\n  // The parser stores options it doesn't recognize here. See above.\r\n  repeated UninterpretedOption uninterpreted_option = 999;\r\n\r\n  // Clients can define custom options in extensions of this message. See above.\r\n  extensions 1000 to max;\r\n}\r\n\r\nmessage MessageOptions {\r\n  // Set true to use the old proto1 MessageSet wire format for extensions.\r\n  // This is provided for backwards-compatibility with the MessageSet wire\r\n  // format.  You should not use this for any other reason:  It's less\r\n  // efficient, has fewer features, and is more complicated.\r\n  //\r\n  // The message must be defined exactly as follows:\r\n  //   message Foo {\r\n  //     option message_set_wire_format = true;\r\n  //     extensions 4 to max;\r\n  //   }\r\n  // Note that the message cannot have any defined fields; MessageSets only\r\n  // have extensions.\r\n  //\r\n  // All extensions of your type must be singular messages; e.g. they cannot\r\n  // be int32s, enums, or repeated messages.\r\n  //\r\n  // Because this is an option, the above two restrictions are not enforced by\r\n  // the protocol compiler.\r\n  optional bool message_set_wire_format = 1 [default=false];\r\n\r\n  // Disables the generation of the standard \"descriptor()\" accessor, which can\r\n  // conflict with a field of the same name.  This is meant to make migration\r\n  // from proto1 easier; new code should avoid fields named \"descriptor\".\r\n  optional bool no_standard_descriptor_accessor = 2 [default=false];\r\n\r\n  // The parser stores options it doesn't recognize here. See above.\r\n  repeated UninterpretedOption uninterpreted_option = 999;\r\n\r\n  // Clients can define custom options in extensions of this message. See above.\r\n  extensions 1000 to max;\r\n}\r\n\r\nmessage FieldOptions {\r\n  // The ctype option instructs the C++ code generator to use a different\r\n  // representation of the field than it normally would.  See the specific\r\n  // options below.  This option is not yet implemented in the open source\r\n  // release -- sorry, we'll try to include it in a future version!\r\n  optional CType ctype = 1 [default = STRING];\r\n  enum CType {\r\n    // Default mode.\r\n    STRING = 0;\r\n\r\n    CORD = 1;\r\n\r\n    STRING_PIECE = 2;\r\n  }\r\n  // The packed option can be enabled for repeated primitive fields to enable\r\n  // a more efficient representation on the wire. Rather than repeatedly\r\n  // writing the tag and type for each element, the entire array is encoded as\r\n  // a single length-delimited blob.\r\n  optional bool packed = 2;\r\n\r\n\r\n  // Is this field deprecated?\r\n  // Depending on the target platform, this can emit Deprecated annotations\r\n  // for accessors, or it will be completely ignored; in the very least, this\r\n  // is a formalization for deprecating fields.\r\n  optional bool deprecated = 3 [default=false];\r\n\r\n  // EXPERIMENTAL.  DO NOT USE.\r\n  // For \"map\" fields, the name of the field in the enclosed type that\r\n  // is the key for this map.  For example, suppose we have:\r\n  //   message Item {\r\n  //     required string name = 1;\r\n  //     required string value = 2;\r\n  //   }\r\n  //   message Config {\r\n  //     repeated Item items = 1 [experimental_map_key=\"name\"];\r\n  //   }\r\n  // In this situation, the map key for Item will be set to \"name\".\r\n  // TODO: Fully-implement this, then remove the \"experimental_\" prefix.\r\n  optional string experimental_map_key = 9;\r\n\r\n  // The parser stores options it doesn't recognize here. See above.\r\n  repeated UninterpretedOption uninterpreted_option = 999;\r\n\r\n  // Clients can define custom options in extensions of this message. See above.\r\n  extensions 1000 to max;\r\n}\r\n\r\nmessage EnumOptions {\r\n\r\n  // The parser stores options it doesn't recognize here. See above.\r\n  repeated UninterpretedOption uninterpreted_option = 999;\r\n\r\n  // Clients can define custom options in extensions of this message. See above.\r\n  extensions 1000 to max;\r\n}\r\n\r\nmessage EnumValueOptions {\r\n  // The parser stores options it doesn't recognize here. See above.\r\n  repeated UninterpretedOption uninterpreted_option = 999;\r\n\r\n  // Clients can define custom options in extensions of this message. See above.\r\n  extensions 1000 to max;\r\n}\r\n\r\nmessage ServiceOptions {\r\n\r\n  // Note:  Field numbers 1 through 32 are reserved for Google's internal RPC\r\n  //   framework.  We apologize for hoarding these numbers to ourselves, but\r\n  //   we were already using them long before we decided to release Protocol\r\n  //   Buffers.\r\n\r\n  // The parser stores options it doesn't recognize here. See above.\r\n  repeated UninterpretedOption uninterpreted_option = 999;\r\n\r\n  // Clients can define custom options in extensions of this message. See above.\r\n  extensions 1000 to max;\r\n}\r\n\r\nmessage MethodOptions {\r\n\r\n  // Note:  Field numbers 1 through 32 are reserved for Google's internal RPC\r\n  //   framework.  We apologize for hoarding these numbers to ourselves, but\r\n  //   we were already using them long before we decided to release Protocol\r\n  //   Buffers.\r\n\r\n  // The parser stores options it doesn't recognize here. See above.\r\n  repeated UninterpretedOption uninterpreted_option = 999;\r\n\r\n  // Clients can define custom options in extensions of this message. See above.\r\n  extensions 1000 to max;\r\n}\r\n\r\n// A message representing a option the parser does not recognize. This only\r\n// appears in options protos created by the compiler::Parser class.\r\n// DescriptorPool resolves these when building Descriptor objects. Therefore,\r\n// options protos in descriptor objects (e.g. returned by Descriptor::options(),\r\n// or produced by Descriptor::CopyTo()) will never have UninterpretedOptions\r\n// in them.\r\nmessage UninterpretedOption {\r\n  // The name of the uninterpreted option.  Each string represents a segment in\r\n  // a dot-separated name.  is_extension is true iff a segment represents an\r\n  // extension (denoted with parentheses in options specs in .proto files).\r\n  // E.g.,{ [\"foo\", false], [\"bar.baz\", true], [\"qux\", false] } represents\r\n  // \"foo.(bar.baz).qux\".\r\n  message NamePart {\r\n    required string name_part = 1;\r\n    required bool is_extension = 2;\r\n  }\r\n  repeated NamePart name = 2;\r\n\r\n  // The value of the uninterpreted option, in whatever type the tokenizer\r\n  // identified it as during parsing. Exactly one of these should be set.\r\n  optional string identifier_value = 3;\r\n  optional uint64 positive_int_value = 4;\r\n  optional int64 negative_int_value = 5;\r\n  optional double double_value = 6;\r\n  optional bytes string_value = 7;\r\n  optional string aggregate_value = 8;\r\n}\r\n\r\n// ===================================================================\r\n// Optional source code info\r\n\r\n// Encapsulates information about the original source file from which a\r\n// FileDescriptorProto was generated.\r\nmessage SourceCodeInfo {\r\n  // A Location identifies a piece of source code in a .proto file which\r\n  // corresponds to a particular definition.  This information is intended\r\n  // to be useful to IDEs, code indexers, documentation generators, and similar\r\n  // tools.\r\n  //\r\n  // For example, say we have a file like:\r\n  //   message Foo {\r\n  //     optional string foo = 1;\r\n  //   }\r\n  // Let's look at just the field definition:\r\n  //   optional string foo = 1;\r\n  //   ^       ^^     ^^  ^  ^^^\r\n  //   a       bc     de  f  ghi\r\n  // We have the following locations:\r\n  //   span   path               represents\r\n  //   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.\r\n  //   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).\r\n  //   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).\r\n  //   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).\r\n  //   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).\r\n  //\r\n  // Notes:\r\n  // - A location may refer to a repeated field itself (i.e. not to any\r\n  //   particular index within it).  This is used whenever a set of elements are\r\n  //   logically enclosed in a single code segment.  For example, an entire\r\n  //   extend block (possibly containing multiple extension definitions) will\r\n  //   have an outer location whose path refers to the \"extensions\" repeated\r\n  //   field without an index.\r\n  // - Multiple locations may have the same path.  This happens when a single\r\n  //   logical declaration is spread out across multiple places.  The most\r\n  //   obvious example is the \"extend\" block again -- there may be multiple\r\n  //   extend blocks in the same scope, each of which will have the same path.\r\n  // - A location's span is not always a subset of its parent's span.  For\r\n  //   example, the \"extendee\" of an extension declaration appears at the\r\n  //   beginning of the \"extend\" block and is shared by all extensions within\r\n  //   the block.\r\n  // - Just because a location's span is a subset of some other location's span\r\n  //   does not mean that it is a descendent.  For example, a \"group\" defines\r\n  //   both a type and a field in a single declaration.  Thus, the locations\r\n  //   corresponding to the type and field and their components will overlap.\r\n  // - Code which tries to interpret locations should probably be designed to\r\n  //   ignore those that it doesn't understand, as more types of locations could\r\n  //   be recorded in the future.\r\n  repeated Location location = 1;\r\n  message Location {\r\n    // Identifies which part of the FileDescriptorProto was defined at this\r\n    // location.\r\n    //\r\n    // Each element is a field number or an index.  They form a path from\r\n    // the root FileDescriptorProto to the place where the definition.  For\r\n    // example, this path:\r\n    //   [ 4, 3, 2, 7, 1 ]\r\n    // refers to:\r\n    //   file.message_type(3)  // 4, 3\r\n    //       .field(7)         // 2, 7\r\n    //       .name()           // 1\r\n    // This is because FileDescriptorProto.message_type has field number 4:\r\n    //   repeated DescriptorProto message_type = 4;\r\n    // and DescriptorProto.field has field number 2:\r\n    //   repeated FieldDescriptorProto field = 2;\r\n    // and FieldDescriptorProto.name has field number 1:\r\n    //   optional string name = 1;\r\n    //\r\n    // Thus, the above path gives the location of a field name.  If we removed\r\n    // the last element:\r\n    //   [ 4, 3, 2, 7 ]\r\n    // this path refers to the whole field declaration (from the beginning\r\n    // of the label to the terminating semicolon).\r\n    repeated int32 path = 1 [packed=true];\r\n\r\n    // Always has exactly three or four elements: start line, start column,\r\n    // end line (optional, otherwise assumed same as start line), end column.\r\n    // These are packed into a single field for efficiency.  Note that line\r\n    // and column numbers are zero-based -- typically you will want to add\r\n    // 1 to each before displaying to a user.\r\n    repeated int32 span = 2 [packed=true];\r\n\r\n    // TODO(kenton):  Record comments appearing before and after the\r\n    // declaration.\r\n  }\r\n}\r\n"}